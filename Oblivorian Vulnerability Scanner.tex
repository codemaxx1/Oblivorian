\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Oblivorian Vulnerability Scanner\\
}

\author{\IEEEauthorblockN{Nicholas Garrett}
\IEEEauthorblockA{\textit{Computer Science} \\
\textit{Idaho State University}\\
Pocatello, Idaho, United States \\
garrnic3@isu.edu}
}

\maketitle

\begin{abstract}
Computer system vulnerabilities are far from uncommon and in this increasingly computer-driven world, patching these vulnerabilities is becoming more and more important.  In response to the growing number of available security flaws, vulnerability scanning systems have been implemented and made available to scan phones, personal computers, and an increasing spread of devices to detect these flaws--some even work to repair these flaws.  

Described in this paper is a small-scale vulnerability scanning system meant to search a target computer system for some simple exploitable security points.  This program, written in mainly the Python3 programming language and dubbed ``Oblivorian'', is designed to run in a mainly educational envirement, mainly intended to explore existing functionality of vulnerability scanners.  However, this program does act to explore some of the actual mechanics used in commercial-grade scanners.
\end{abstract}


\section{Introduction}
When the first commercially available personal computer, the Kenbak-1, was released to the 
public in 1971\cite{b1}, the concept of computer viruses was only that—a concept.  It was not until the spread of the Creeper Virus of that same year that the need for cyber security became evident.  Prior to Creeper, popularly known as the first computer virus\cite{b2}, the practical need for implementations to avoid vulnerabilities only contained bug-fixing and avoiding system errors.  However, with the rising popularity and prevalence of computer viruses being spread from system to system, the importance of maintaining security and preventing cyber attack is rising as well.  \\

	In this paper, I describe a software system I have built intended to detect common exploitable issues easily detectable on a computer system.  I will also explain these possible exploits and how they pose issue and threat to computer systems.  Each of the exploits I will describe—or methods to reach exploit—are useful to an attacker intending to gain access to a computer system.  \\
	

\section{Oblivorian}
As previously described, vulnerability scanning programs have become more and more important as the number of cyber attacks made against computer systems has been increasing an ever-increasing rate.  Often, the actual implementations and methods used by scanning software seem vague and unconvincing\cite{b10}.  In other words, how vulnerability scannning programs operate is very often hidden from the user; what a user sees is only the end determinations and recommendations made by the program.

So, in order to greater appreciate the availability of scanning software and understand the algorithms used in those programs, I have implemented a software program to try and actually check for some of these vulnerabilities.  The software program I have built to solve some of these issues in cybersecurity is called Oblivorian.  \\

	The name ``Oblivorian'' is derived from the two key words of ``Oblivion'' and ``Orion''.  ``Oblivion'', as defined by Merriam-Webster, is ``a state marked by lack of awareness or consciousness''\cite{b11}.  This base word was chosen as it describes the lack of knowledge on the topic of vulnerabilities and scanning, and general ignorance prior to actually building the system.  The second base word, ``Orion'', was chosen for a different reason.  The constellation Orion is also known by another name: the hunter.  This software program is intended to hunt for vulnerabilities of a target system.  
	These two base words describe the hope of Oblivorian: to hunt for vulnerabilities of a system and destroy the ignorance of how cyber-threat scanning works. \\
	
	Past the etymology of Oblivorian, the actual implementation of such a system is significantly more important than the system itself.  Oblivorian is presently written in Python3 due to the high-level of control available in such a language.  Python3 is often looked down on by programmers due to how high-level it is in terms of control--it is so far away from systems programming that there can be little trust in it serving as an effective scanner of vulnerabilities.  This is understood, and given time, Oblivorian is expected to be implemented, at least partially, in a lower-level language--a language like C. \\
	
	This software program is designed to scan a computer system for some of the simple vulnerabilities seen.  And, as with almost any software system, Oblivorian is a continuously changing software program designed to change and improve over time.  Hopefully, given enough time, this program will be able to scan for more advanced and difficult software vulnerabilities beyond some of the simple surface-level vulnerabilities is is currently capable of checking.  Of  course, it is unfortunately limited by my abilities in programming and by the extent of my understanding in cybersecurity principles.  As I become more competent and knowledgeable about cybersecurity and vulnerability scanning principles, I will add to Oblivorian and hopefully build it into a competant scanning system.  \\
	
	Unfortunately, Oblivorian is only designed to operate on a linux machine.  This is mainly due to some of the slight differences in how commands are supposed to be run between the two systems.  While there is some OS checking incorperated in Oblivorian to allow for slightly different scripts or commands to be run depending on the OS, not all the functions incorperate this checking, so some features will either malfunction or might even outright fail on a Windows system. \\  
	
	Throughout the extent of this paper, I will describe various generic vulnerabilities that are easy to check and how Oblivorian works to fix or detect these vulnerabilities.  Of course, not all of the points discussed will be vulnerabilities per se, for example the System Information scanning.  However, they all are involved in vulnerability scanning, or the availability of such information can help an attacker to better attack or gain access to a system. \\
	

\section{Port Scanner}
	Internet ports are an important part of connecting a computer system to the outside world. Through them information and data can be both sent and received across the internet.  Through this, a personal computer in Japan, for example, is capable to sending data to another system anywhere else in the world.  
	
	However, while network ports must be open in order to connect to the outside world, this is a double-edged sword: every open port is a potential vulnerability that an attacker could exploit.  An attacker needs only to gain access to a port and they can then possibly get information about your system and open doors for the execution of malicious software.  At this point, an attacker effectively has control of the targeted system. \\
	
	Often, specific ports will be opened by a process to connect to some remote servers.  An example of this is the VMware process, which listens on port 902\cite{b8}. This service is not always running and not all computer systems even have VMware installed. So, logically, unless some program or process opens and listens to this port, it will by default remain closed.  When a process does open and begin listening on a port, it will open that port for as long as the process is running. However, just because some process opens a port, that does not inherently mean that it is actively listening to that port.  It is not too uncommon for ports to be left open for no reason--it is these ports in particular that can pose a security risk.  Therefore, in order to ensure our computer system is more secure than otherwise, we should make sure that only ports we want to be open remain so, and all non-actively used ports are closed. 

	However, what defines a used verses an unused port?  Simply put, a used port is one in which the daemon, a program that runs in the background without input from the user, is still listening on a port.  Therefore, by the logical conjugate, we can say that unused ports are those in which no daemon is listening for incoming traffic.\\ 
	
	Our first thought might be to simply close all the ports we do not want to use.  This would prevent attackers from retrieving information about our system.  Logically, such an action would improve the port-security of the defending system; it would also act to reduce the avaijlable vulnerabilities an attacker can use in their attempts to control a target system.  However, this impulsive action could lead to necessary ports being closed.  
	
	Suppose we close the ports necessary for HTTP or HTTPS (80 and 443 respectively), suddenly we would find that internet browsing programs no longer work, as HTTP and HTTPS are important in transferring the data used in internet browsing. 

	Thus, we can see that closing ports without first seeing what they do or closing ports often used, can lead to the processes using those ports to malfunction or fail.  Therefore, we must be careful not only to close unused ports, but also to not close open ports that are used frequently.\\
	
	Instead of automatically closing open ports when they are found, if we list the ports and give to the user the option of what ports to close, giving to them an explanation of what the purpose of these ports are, the risk of closing ports best left open can be decreased and control can be put into the hands of the user.  
	
	Following this plan, it is quite possible that the list of open ports may be quite large.  For example, Mac-OS websites state that as about 132 ports are open by default on many Apple services.  To improve user experience, it would be more convenient to somehow filter through ports that should be closed, only leaving ports with an active owner up to the user to close if wished.
	
	Thus, Oblivorian’s scanning feature scans through port numbers 1 through 65535.  The method of searching for open ports is through attempting to connect to the ports in iterative sequence; if a connection is able to be made, then that indicates that a service is listening on that port.  So, Oblivorian adds each port where a connection could be made into an array and asks the user whether or not to terminate all processes listening-in on that port.\\


\section{System and Processor information}
Accessing system information on a target computer system is important in scanning for vulnerabilities.  Something as simple as determining a computer's Operating System can help attackers to narrow down and target particular vulnerabilities.  
For instance, Windows XP has software vulnerabilities that are specific to it, whereas Windows 98 has its own OS-specific vulnerabilities--relatively few of these assailable points are shared between the two systems compared to the number of attacks able to be made to exclusively a single Operating System\cite{b9}.  

This is not an offense against Windows XP or Windows 98 in particular, every Operating System has its own set  of vulnerabilities--it is almost impossible to completely remove the presence of hackable points.  Rather, this should go to explain and demonstrate that vulnerabilities exist that are not shared among multiple operating systems.  

If an attacker is able to narrow down what  type of system they are attacking--even if the exact operating system is still indeterminable--they can more specifically and actively narrow down the available software attacks that can be made against the system.  If the exact operating system, release, version, processor, or even if it is a 64 or 32 bit machine can be determined, an attacker can better and more accurately narrow-down the list of attacks they should make that are the most likely to break the target systems countermeasures and gain access to the system.\\

In March 2018, researchers at Ohio State University in the United States announced a method to breach the internal security for an Intel CPU\cite{b16}.  In this published exploit, researchers described a method through which an attacker is able to gain access to the system and can both read and write memory.  The researchers who published this vulnerability dubbed it ``SgxPectre''\cite{b15}.  

This is just one example of a hardware-specific vulnerable attack that can be made against a system if the information can be determined.  

\subsection{Determination of processor by mathematical calculations}
The issue of a processor-specific vulnerabilities being used against a specific computer processor is a much more difficult issue to protect against than Operating System vulnerabilities\cite{b12}.  However, it is luckily also quite difficult to determine what processor a target system is using.   

Unfortunately, research is showing that while it is difficult to identify the processor of a system without having access to that level of information, it is not impossible.  One method of determining what processor a system is using is through the actual calculations made by that processor. \\

Due to the physical makeup of different processors, as well as the algorithms used for mathematical calculation, the return they give for mathematical approximations are variant.  It is in the nature of their construction that the algorithmic and approximation errors will vary by a small degree from the exact solution for some mathematical calculation\cite{b17}.  For example, if one were to calculate \(\sqrt{2}\) on some computer system, an approximation for that solution would be returned.  If then, one were to compare the calculated return for \(\sqrt{2}^2\) and 2, the two would not be equivalent\cite{b13}.

Taking advantage of this variance, we can get a reasonably accurate idea of what specific processor a system uses.  A practical implementation of such a method follows: if we define some mathematical operation, then certain expected values will be returned by mathematical operations.  Further, each of the values returned will be slightly different depending on each processor chip.

\begin{center}
\begin{tabular}{ |p{1.5cm}||p{1.5cm}|p{1.5cm}|p{1cm}|| }

 \hline
 Processor	& \(sin(10^{10} \pi_1)\) & \(sin(10^{17} \pi_1)\) & \(sin(10^{37} \pi_1)\)\\
 \hline
 IPHONE 3G   	& 0.375...		& 0.423... 	&  -0.837 \\
  AMD 32 	&  0.375... 	& 0.424... 	& -0.837 \\
 AMD 64 		&  0.375... 	& 0.424... 	&  0.837 \\
 ATOM    		& 0.375... 	& 0.423... 	&  -0.832 \\
 INTEL DC 	& 0.375...		& 0.423...		& -0.832 \\
 MIPS 12000	& 0.375...  	& 0.423...   	& -0.832 \\
 dsPIC33 		& 0.81...  		& 0.62... 		& -0.44  \\
 \hline 
 \multicolumn{4}{l}{Table 1: Float calculations for various processors\cite{b13}. }\\
\end{tabular}\\
\end{center}

Table 1 shows some examples of how mathematical calculations differ slightly for different processors.  \\

In order to test this principle--to the limited degree of available and accessible data--Oblivorian includes a C script which runs the calculations of \(sin(10^{10} \pi), \, sin(10^{17} \pi)\), and  \(sin(10^{37} \pi)\) to try and determine the processor of the running system.  
Unfortunately, the degree to which this calculation narrows down the specific processor is still incomplete, as limited information about the actual returns for such calculations is available.  

	The only information that could easily be found is the data listed in Table 1, which quite obviously does not encompass a particularly wide range of processors that can be identified.  Thus, unfortunately the script included in Oblivorian to test based on processor float calculations is fatally lacking in the range of processors it can determine. \\


\section{Internet Identifiability}

\section{Sniffer}

\section{Serial Port Scanning}

\section*{References}

Please number citations consecutively within brackets \cite{b1}. The 
sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference 
number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at 
the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''

Number footnotes separately in superscripts. Place the actual footnote at 
the bottom of the column in which it was cited. Do not put footnotes in the 
abstract or reference list. Use letters for table footnotes.

Unless there are six authors or more give all authors' names; do not use 
``et al.''. Papers that have not been published, even if they have been 
submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers 
that have been accepted for publication should be cited as ``in press'' \cite{b5}. 
Capitalize only the first word in a paper title, except for proper nouns and 
element symbols.

For papers published in translation journals, please give the English 
citation first, followed by the original foreign-language citation \cite{b6}.

\begin{thebibliography}{00}
\bibitem{b1} Baqué, Achim. n.d. “The First Personal Computer.” The First Personal Computer. Accessed November 30, 2021. http://www.thefirstpc.com/..

\bibitem{b2} “Creeper: The World’s First Computer Virus.” 2019. Exabeam. March 5, 2019. http://www.exabeam.com/information-security/creeper-computer-virus/.

\bibitem{b4} “What Is Port Scanning and How Does It Work? | Avast.” n.d. Www.avast.com. https://www.avast.com/business/resources/what-is-port-scanning\#pc.

\bibitem{b5} “SecurityTrails | What Are Open Ports?” Securitytrails.com, securitytrails.com/blog/open-ports. Accessed 30 Nov. 2021.

\bibitem{b6} YHartwig, Chris. “Why Closing Unused Server Ports Is Critical to Cyber Security.” Blog.getcryptostopper.com, blog.getcryptostopper.com/why-closing-unused-server-ports-is-critical-to-cyber-security. Accessed 30 Nov. 2021.

\bibitem{b7} “Is It Possible in Python to Kill Process That Is Listening on Specific Port, for Example 8080?” Stack Overflow, stackoverflow.com/questions/20691258/is-it-possible-in-python-to-kill-process-that-is-listening-on-specific-port-for.. Accessed 30 Nov. 2021.

\bibitem{b8} “Common Ports Cheat Sheet - Most Common Network Ports You Need to Know.” n.d. The Dark Source. Accessed December 1, 2021. https://thedarksource.com/common-ports-cheat-sheet/.

\bibitem{b9} Alhazmi, O, Y Malaiya, and I Ray. 2004. “Technical Report Vulnerabilities in Major Operating Systems.” https://www.cs.colostate.edu/~malaiya/vulnerabilities.pdf.

\bibitem{b10} Gilroy, John, Jabez Olssen, and Colin Goudie, eds. 2016. Rogue One: A Star Wars Story. Directed by Gareth Edwards. Walt Disney Studios Motion Pictures.

\bibitem{b11} “Definition of OBLIVION.” Www.merriam-Webster.com, www.merriam-webster.com/dictionary/oblivion.

\bibitem{b12} “New Class of Malware Attacks Specific Chips.” n.d. MIT Technology Review. Accessed December 6, 2021. https://www.technologyreview.com/2010/11/10/261216/new-class-of-malware-attacks-specific-chips/.

\bibitem{b13} Desnos, Anthony, Robert Erra, and Eric Filiol. 2010. “Processor-Dependent Malware... And Codes *.” https://arxiv.org/pdf/1011.1638.pdf.

\bibitem{b14} “Arm’d \& Dangerous.” n.d. Objective-See.com. Accessed December 6, 2021. https://objective-see.com/blog/blog\_0x62.html.

\bibitem{b15} “CPU Vulnerabilities | How CPU Flaws Can Lead to Exploits.” 2018. Finjan Blog. September 17, 2018. https://blog.finjan.com/cpu-vulnerabilities-how-cpu-flaws-can-lead-to-exploits/.

\bibitem{b16} Patrizio, Andy. “New Spectre Derivative Bug Haunts Intel Processors.” Network World, 7 Mar. 2018, www.networkworld.com/article/3261087/new-spectre-derivative-bug-haunts-intel-processors.html. Accessed 7 Dec. 2021.

\bibitem{b17} Review of Computer Numbers and Their Precision II Errors and Uncertainties in Calculations. n.d. Accessed December 2021. http://sites.science.oregonstate.edu/~landaur/INSTANCES/WebModules/1\_ComputerPrecision/PrecisionFiles/Pdfs/PrecisionII\_15Sept.pdf.

\bibitem{b18} “Get Your System Information - Using Python Script.” GeeksforGeeks, 19 May 2020, www.geeksforgeeks.org/get-your-system-information-using-python-script/. Accessed 8 Dec. 2021.
 
 \bibitem{b19} Alhazmi, O, Y Malaiya, and I Ray. 2004. “Technical Report Vulnerabilities in Major Operating Systems.” https://www.cs.colostate.edu/~malaiya/vulnerabilities.pdf.
 
 

\end{thebibliography}

\end{document}
